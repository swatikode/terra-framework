(window.webpackJsonp=window.webpackJsonp||[]).push([[179],{1005:function(e,n){},1402:function(e,n,t){"use strict";var i=t(5);Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var r=i(t(231)),a=i(t(20)),u=i(t(22)),l=function(){function e(){(0,a.default)(this,e)}return(0,u.default)(e,null,[{key:"isUnderMaxLength",value:function(e,n){return!(!("string"==typeof e||e instanceof String)||"number"!=typeof n||!isFinite(n)||n<0||!Number.isInteger(n))&&e.length<=n}},{key:"isOverMinLength",value:function(e,n){return!(!("string"==typeof e||e instanceof String)||"number"!=typeof n||!isFinite(n)||n<0||!Number.isInteger(n))&&e.length>=n}},{key:"hasNoWhitespace",value:function(e){return("string"==typeof e||e instanceof String)&&!/\s/.test(e)}},{key:"containsCharacters",value:function(e,n){if(!("string"==typeof e||e instanceof String)||!n||"object"!==(0,r.default)(n)||n.constructor!==Array)return!1;for(var t=0;t<n.length;t+=1)if(e.includes(n[t]))return!0;return!1}},{key:"isOverMinValue",value:function(e,n){return!(!("string"==typeof e||e instanceof String)||"number"!=typeof n||!isFinite(n))&&e>=n}},{key:"isUnderMaxValue",value:function(e,n){return!(!("string"==typeof e||e instanceof String)||"number"!=typeof n||!isFinite(n))&&e<=n}},{key:"isPrecise",value:function(e,n){if(!("string"==typeof e||e instanceof String)||"number"!=typeof n||!isFinite(n)||n<0||!Number.isInteger(n))return!1;var t=e.split(".");return!(2===t.length&&t[1].length>n)}},{key:"isNonnegative",value:function(e){return("string"==typeof e||e instanceof String)&&parseFloat(e)>=0}}]),e}();n.default=l},2013:function(e,n,t){"use strict";t.r(n),n.default="# Making a Numeric Input With Minimum, Maximum, and Precision Validations\n\nSince this is a more in depth view of validation, we're going to just start with some provided code and add to it as needed.\n\n```javascript\nimport React from 'react';\nimport { Form, Field } from 'react-final-form';\nimport InputField from 'terra-form-input/lib/InputField';\nimport Button from 'terra-button';\nimport Spacer from 'terra-spacer';\n\nconst validateNumber = (value) => {\n  if (!value) { return undefined; }\n\n  return undefined;\n};\n\nexport default class Example extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {};\n    this.submitForm = this.submitForm.bind(this);\n  }\n\n  submitForm(values) {\n    this.setState({\n      submittedValues: values,\n    });\n  }\n\n  renderForm({ handleSubmit }) {\n    return (\n      <form\n        noValidate\n        onSubmit={handleSubmit}\n      >\n        <Field\n          name=\"numExample\"\n          validate={validateNumber}\n        >\n          {({ input, meta }) => (\n            <InputField\n              inputId=\"numExample\"\n              label=\"Numeric Example\"\n              error={meta.error}\n              isInvalid={meta.error !== undefined}\n              inputAttrs={{\n                type: 'number',\n                ...input,\n              }}\n              onChange={(e) => { input.onChange(e.target.value); }}\n              value={input.value}\n              required\n            />\n          )}\n        </Field>\n        <Button text=\"Submit\" type={Button.Opts.Types.SUBMIT} />\n      </form>\n    );\n  }\n\n  render() {\n    return (\n      <Spacer marginBottom=\"small\">\n        <Form\n          onSubmit={this.submitForm}\n          render={this.renderForm}\n          initialValues={{ numExample: '' }}\n          validate={(values) => {\n            const errors = {};\n\n            if (!values.numExample) {\n              errors.numExample = 'Required';\n            }\n\n            return errors;\n          }}\n        />\n        {this.state.submittedValues\n          && (\n          <div>\n            <p>Form Submitted Successfully With</p>\n            <pre>{JSON.stringify(this.state.submittedValues, 0, 2)}</pre>\n          </div>\n          )\n        }\n      </Spacer>\n    );\n  }\n}\n```\n\nWe have a simple number type input with validation, tied to the `<Form>` component, that checks whether we have a value for the input.\n\nWe also have our `<Field>`'s validation function defined and ready to be added to, with it only having a basic check to see if there is a value.\n\nWe have added browser enforcement on the inputted value by passing `type: 'number'` into `<Inputfield>`'s `inputAttrs`.\n\nNote that specifying `type: 'number'` still allows negatives and decimal points, such as `--1` or `2.0.32`. These will be placed in the field as `undefined`. With our code, we will just return a value of `Required`, via the `<Form>`'s validation function, if values are undefined.\n\nSecond thing - our validation function, `validateNumber`, will be given a *string*, despite the input being of `type: 'number'`. This does not impact simple operators but is useful to know when building custom validation functions.\n\nLet's start by giving a minimum and maximum to our value. For simplicity, set a minimum to 10 and a maximum to 100.\n\n```diff\nconst validateNumber = (value) => {\n  if (!value) { return undefined; }\n+ var numericValue = Number(value);\n+ if (numericValue < 10) {\n+   return 'Value should not be less than 10.';\n+ }\n+ if (numericValue > 100) {\n+   return 'Value should not be over 100.';\n+ }\n\n  return undefined;\n};\n```\n\nNow, let's check for precision. For this example, lets validate to the thousandth place (three decimal places). Since our value is a string, we'll use string functions to validate.\n\nUse `.` as a delimiter and check for a length less than or equal to 3.\n\n```diff\nconst validateNumber = (value) => {\n  ...\n+ const valueSplit = value.split('.');\n+ if (valueSplit.length === 2 && valueSplit[1].length > 3) {\n+   return 'Value has more than 3 decimal points';\n+ }\n\n  return undefined;\n};\n```\n\nThis validation has a quirk. If the input contains extra `0`s, like `23.0230000`, validation will fail.\n\nLet's try a different way of validating. Using the `Number` converted value instead, we can use the `toFixed` function to automatically set precision, and use this as a comparison.\n\n```diff\nconst validateNumber = (value) => {\n  if (!value) { return undefined; }\n  var numericValue = Number(value);\n  ...\n- const valueSplit = value.split('.');\n- if (valueSplit.length === 2 && valueSplit[1].length > 3) {\n+ if (numericValue.toFixed(3) != numericValue) {\n    return 'Value has more than 3 decimal points';\n  }\n\n  return undefined;\n};\n```\n\nThis validation has the opposite quirk. If the input contains extra `0`s, like `23.0230000`, validation will succeed.\n\nWith this we have a function that we can add to validate a number based by having a minimum, maximum, and a certain level of precision required. In the same vein as the 'Max Length Input' example, we can use the `FormValidationUtil` to help control and reduce some of workflow.\n\n```diff\nconst validateNumber = (value) => {\n   if (!value) { return undefined; }\n-  var numericValue = Number(value);\n-  if (numericValue < 10) {\n+  if (!FormValidationUtil.isOverMinValue(value, 10)) {\n    return 'Value should not be less than 10.';\n  }\n-  if (numericValue > 100) {\n+  if (!FormValidationUtil.isUnderMaxValue(value, 100)) {\n    return 'Value should not be over 100.';\n  }\n- if (numericValue.toFixed(3) != numericValue) {\n+ if (!FormValidationUtil.isPrecise(value, 3)) {\n    return 'Value has more than 3 decimal points';\n  }\n\n  return undefined;\n};\n```\n\nNote: The `FormValidationUtil.precisionCheck` function uses the method where we split the `String` value to check precision.\n"},2014:function(e,n,t){"use strict";var i=t(5);Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var r=i(t(163)),a=i(t(20)),u=i(t(22)),l=i(t(23)),o=i(t(24)),s=i(t(27)),m=i(t(25)),d=i(t(0)),f=t(1079),c=i(t(1080)),p=i(t(54)),v=i(t(363)),h=i(t(1402));function b(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function g(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?b(Object(t),!0).forEach((function(n){(0,r.default)(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):b(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var y=function(e){return h.default.isOverMinValue(e,10)?h.default.isUnderMaxValue(e,100)?h.default.isPrecise(e,3)?void 0:"Value has more than 3 decimal points":"Value should not be over 100.":"Value should not be less than 10."},F=function(e){function n(e){var t;return(0,a.default)(this,n),(t=(0,l.default)(this,(0,o.default)(n).call(this,e))).state={},t.submitForm=t.submitForm.bind((0,s.default)(t)),t}return(0,m.default)(n,e),(0,u.default)(n,[{key:"submitForm",value:function(e){this.setState({submittedValues:e})}},{key:"renderForm",value:function(e){var n=e.handleSubmit;return d.default.createElement("form",{noValidate:!0,onSubmit:n},d.default.createElement(f.Field,{name:"numExample",validate:y},(function(e){var n=e.input,t=e.meta;return d.default.createElement(c.default,{inputId:"numExample",label:"Numeric Example",error:t.error,isInvalid:void 0!==t.error,inputAttrs:g({type:"number"},n),onChange:function(e){n.onChange(e.target.value)},value:n.value,required:!0})})),d.default.createElement(p.default,{text:"Submit",type:p.default.Opts.Types.SUBMIT}))}},{key:"render",value:function(){return d.default.createElement(v.default,{marginBottom:"small"},d.default.createElement(f.Form,{onSubmit:this.submitForm,render:this.renderForm,initialValues:{numExample:""},validate:function(e){var n={};return e.numExample||(n.numExample="Required"),n}}),this.state.submittedValues&&d.default.createElement("div",null,d.default.createElement("p",null,"Form Submitted Successfully With"),d.default.createElement("pre",null,JSON.stringify(this.state.submittedValues,0,2))))}}]),n}(d.default.Component);n.default=F},2015:function(e,n,t){"use strict";t.r(n),n.default="/* eslint-disable class-methods-use-this */\n\nimport React from 'react';\nimport { Form, Field } from 'react-final-form';\nimport InputField from 'terra-form-input/lib/InputField';\nimport Button from 'terra-button';\nimport Spacer from 'terra-spacer';\nimport FormValidationUtil from '../../../FormValidationUtil';\n\nconst validateNumber = (value) => {\n  if (!FormValidationUtil.isOverMinValue(value, 10)) {\n    return 'Value should not be less than 10.';\n  }\n  if (!FormValidationUtil.isUnderMaxValue(value, 100)) {\n    return 'Value should not be over 100.';\n  }\n  if (!FormValidationUtil.isPrecise(value, 3)) {\n    return 'Value has more than 3 decimal points';\n  }\n\n  return undefined;\n};\n\nexport default class Example extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {};\n    this.submitForm = this.submitForm.bind(this);\n  }\n\n  submitForm(values) {\n    this.setState({\n      submittedValues: values,\n    });\n  }\n\n  renderForm({ handleSubmit }) {\n    return (\n      <form\n        noValidate\n        onSubmit={handleSubmit}\n      >\n        <Field\n          name=\"numExample\"\n          validate={validateNumber}\n        >\n          {({ input, meta }) => (\n            <InputField\n              inputId=\"numExample\"\n              label=\"Numeric Example\"\n              error={meta.error}\n              isInvalid={meta.error !== undefined}\n              inputAttrs={{\n                type: 'number',\n                ...input,\n              }}\n              onChange={(e) => { input.onChange(e.target.value); }}\n              value={input.value}\n              required\n            />\n          )}\n        </Field>\n        <Button text=\"Submit\" type={Button.Opts.Types.SUBMIT} />\n      </form>\n    );\n  }\n\n  render() {\n    return (\n      <Spacer marginBottom=\"small\">\n        <Form\n          onSubmit={this.submitForm}\n          render={this.renderForm}\n          initialValues={{ numExample: '' }}\n          validate={(values) => {\n            const errors = {};\n\n            if (!values.numExample) {\n              errors.numExample = 'Required';\n            }\n\n            return errors;\n          }}\n        />\n        {this.state.submittedValues\n          && (\n          <div>\n            <p>Form Submitted Successfully With</p>\n            <pre>{JSON.stringify(this.state.submittedValues, 0, 2)}</pre>\n          </div>\n          )}\n      </Spacer>\n    );\n  }\n}\n"},2348:function(e,n,t){"use strict";var i=t(5);Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var r=i(t(0)),a=i(t(1004)),u=i(t(2013)),l=i(t(2014)),o=i(t(2015)),s=function(){return r.default.createElement(a.default,{readme:u.default,examples:[{title:"Numeric Validations",example:r.default.createElement(l.default,null),source:o.default}]})};n.default=s}}]);
//# sourceMappingURL=179-e53bd83583376795c69c.js.map