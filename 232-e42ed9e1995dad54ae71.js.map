{"version":3,"sources":["webpack:///./packages/terra-disclosure-manager/docs/README.md","webpack:///./packages/terra-disclosure-manager/src/DisclosureManager.jsx","webpack:///./packages/terra-disclosure-manager/lib/terra-dev-site/doc/disclosure-manager/About.1.doc.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","_react","_terraDocTemplate","_package","_README","_DisclosureManager","_default","createElement","packageName","name","readme","srcPath","concat","propsTables","componentSrc"],"mappings":"uoCAAA,OAAe,wzgB,kCCAf,OAAe,44qB,kCCEf,IAAIA,EAAyBC,EAAQ,GAErCC,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQE,aAAU,EAElB,IAAIC,EAASP,EAAuBC,EAAQ,IAExCO,EAAoBR,EAAuBC,EAAQ,OAEnDQ,EAAWR,EAAQ,MAEnBS,EAAUV,EAAuBC,EAAQ,OAEzCU,EAAqBX,EAAuBC,EAAQ,OAcpDW,EAXU,WACZ,OAAOL,EAAOD,QAAQO,cAAcL,EAAkBF,QAAS,CAC7DQ,YAAaL,EAASM,KACtBC,OAAQN,EAAQJ,QAChBW,QAAS,kEAAkEC,OAAOT,EAASM,MAC3FI,YAAa,CAAC,CACZC,aAAcT,EAAmBL,aAMvCF,EAAQE,QAAUM","file":"232-e42ed9e1995dad54ae71.js","sourcesContent":["export default \"# Terra Disclosure Manager\\n\\nThe DisclosureManager is a stateful component used to manage disclosure presentation.\\n\\n## Getting Started\\n\\n- Install with [npmjs](https://www.npmjs.com):\\n  - `npm install terra-disclosure-manager`\\n\\n<!-- AUTO-GENERATED-CONTENT:START Peer Dependencies -->\\n## Peer Dependencies\\n\\nThis component requires the following peer dependencies be installed in your app for the component to properly function.\\n\\n| Peer Dependency | Version |\\n|-|-|\\n| react | ^16.8.5 |\\n| react-dom | ^16.8.5 |\\n\\n<!-- AUTO-GENERATED-CONTENT:END -->\\n\\nThis package uses React's Context for inter-component communication. A single instance of this package must be installed to ensure that communication occurs between all Context Providers and Consumers. To help ensure a single instance is installed, this package should be defined as a peer dependency in packages that are reusable libraries or otherwise consumed by other packages.\\n\\n## Usage\\n\\n### Rendering\\n\\nThe DisclosureManager does not implement a traditional render function. A `render` prop should be provided to the DisclosureManager in order to render the various components managed by the DisclosureManager. The `render` function should accept an Object parameter containing the DisclosureManager's state.\\n\\n`render` Argument API:\\n\\n|Key|Value|\\n|---|---|\\n|`children`|An Object containing data relative to the children components provided to the DisclosureManager.|\\n|`disclosure`|An Object containing data relative to the components in the disclosure stack.|\\n|`dismissPresentedComponent`|A function that pops the currently disclosed component off the disclosure stack.|\\n|`closeDisclosure`|A function that closes the disclosure and removes all components from the disclosure stack.|\\n|`maximizeDisclosure`|A function that will maximize the disclosure size. If the disclosure cannot be maximized, or if it is already maximized, the function is not provided.|\\n|`minimizeDisclosure`|A function that will minimize the disclosure size. If the disclosure cannot be minimized, or if it is already minimized, the function is not provided.|\\n|`disclosureComponentKeys`|An array of keys representing the components in the disclosure stack.|\\n|`disclosureComponentData`|An Object containing components and associated data representing the state of disclosure stack.|\\n\\n`disclosureComponentData` Object API:\\n\\n|Key|Value|\\n|---|---|\\n|`component`|A component that has been wrapped with the DisclosureManager-provided contexts.|\\n|`headerAdapterData`|An Object containing the header data for the associated component.|\\n\\n`children` Object API:\\n\\n|Key|Value|\\n|---|---|\\n|`components`|An Array of React components to render as content.|\\n\\n`disclosure` Object API:\\n\\n|Key|Value|\\n|---|---|\\n|`components`|An Array of React components to render in a disclosure mechanism.|\\n|`isOpen`|A boolean indicating the current display state of the DisclosureManager.|\\n|`isFocused`|A boolean indicating the current focus state of the DisclosureManager.|\\n|`isMaximized`|A boolean indicating the current maximize state of the DisclosureManager.|\\n|`size`|The String size of the disclosure.|\\n\\n> Note: The `isFocused` value has little relevance now that Terra's AbstractModal and other components directly manage their own focus state. `isFocused` will be removed from the DisclosureManager API in a future major release.\\n\\nExample (using the Modal and SlideGroup):\\n\\n```jsx\\n<DisclosureManager\\n  supportedDisclosureTypes={['modal']}\\n  render={(manager) => (\\n    <div>\\n      {manager.children.components} // These are the Child1 and Child2 components provided as children to the DisclosureManager.\\n      <Modal\\n        isFocused={manager.disclosure.isFocused}\\n        isOpen={manager.disclosure.isOpen}\\n        onRequestClose={() => {\\n          manager.closeDisclosure();\\n        }}\\n        closeOnEsc\\n        closeOnOutsideClick\\n      >\\n        <SlideGroup items={manager.disclosure.components} isAnimated />\\n      </Modal>\\n    </div>\\n  )}\\n>\\n  <Child1 />\\n  <Child2 />\\n</DisclosureManager>\\n\\n```\\n\\n### Interacting with the Disclosure Manager\\n\\nThe DisclosureManager wraps its contents in a context provider that exposes an instance of a DisclosureManagerDelegate, an object containing DisclosureManager APIs, to components based upon their presented location.\\n\\n#### DisclosureManagerContext\\n\\nThe DisclosureManagerContext can be used directly to access the available DisclosureManager APIs.\\n\\n```jsx\\nimport Base from 'terra-base';\\nimport ModalManager from 'terra-modal-manager'; \\nimport { DisclosureManagerContext } from 'terra-disclosure-manager';\\n\\nconst MyDisclosureComponent = () => {\\n  const disclosureManager = React.useContext(DisclosureManagerContext);\\n\\n  return (\\n    <Button\\n      text=\\\"Close Modal\\\"\\n      onClick={() => { \\n        disclosureManager.closeDisclosure();\\n      }}\\n    />\\n  );\\n};\\n\\nconst MyComponent = () => {\\n  const disclosureManager = React.useContext(DisclosureManagerContext);\\n\\n  return (\\n    <Button\\n      text=\\\"Launch Modal\\\"\\n      onClick={() => { \\n        disclosureManager.disclose({\\n          preferredType: 'modal',\\n          content: {\\n            key: 'MY-MODAL-DISCLOSURE',\\n            component: <MyDisclosureComponent />,\\n          }\\n        });\\n      }}\\n    />\\n  );\\n};\\n\\nconst MyApp = () => (\\n  <Base locale=\\\"en\\\">\\n    <ModalManager>\\n      <MyComponent />\\n    </ModalManager>\\n  </Base>\\n)\\n```\\n\\n#### withDisclosureManager\\n\\nComponents can use the higher order component generator `withDisclosureManager()` to wrap themselves automatically in a context consumer and receive a prop named `disclosureManager` containing a DisclosureManagerDelegate instance.\\n\\n```jsx\\nimport Base from 'terra-base';\\nimport ModalManager from 'terra-modal-manager';\\nimport { withDisclosureManager, disclosureManagerShape } from 'terra-disclosure-manager';\\n\\nconst MyDisclosureComponent = withDisclosureManager(({ disclosureManager }) => (\\n  <Button\\n    text=\\\"Close Modal\\\"\\n    onClick={() => {\\n      disclosureManager.closeDisclosure();\\n    }}\\n  />\\n));\\nMyDisclosureComponent.propTypes = {\\n  disclosureManager: disclosureManagerShape,\\n}\\n\\nconst MyComponent = withDisclosureManager({ disclosureManager }) => (\\n  <Button\\n    text=\\\"Launch Modal\\\"\\n    onClick={() => {\\n      disclosureManager.disclose({\\n        preferredType: 'modal',\\n        content: {\\n          key: 'MY-MODAL-DISCLOSURE',\\n          component: <MyDisclosureComponent />,\\n        }\\n      });\\n    }}\\n  />\\n);\\nMyComponent.propTypes = {\\n  disclosureManager: disclosureManagerShape,\\n}\\n\\nconst MyApp = () => (\\n  <Base locale=\\\"en\\\">\\n    <ModalManager>\\n      <MyComponent />\\n    </ModalManager>\\n  </Base>\\n)\\n```\\n\\n#### DisclosureManagerHeaderAdapter\\n\\nImplementations of the DisclosureManager must render a header containing controls for the various disclosure management actions (close, back, maximize/minimize, etc.). The DisclosureManagerHeaderAdapter can be rendered by the disclosed content to inject their own component-specific contents into that header.\\n\\n`DisclosureManagerHeaderAdapter` Props:\\n\\n|Prop|Is Required|Description|\\n|---|---|---|\\n|`title`|optional|A string to render as the header's title.|\\n|`collapsibleMenuView`|optional|A CollapsibleMenuView component to render within the header.|\\n\\n```jsx\\nimport { DisclosureManagerContext, DisclosureManagerHeaderAdapter } from 'terra-disclosure-manager';\\nimport CollapsibleMenuView from 'terra-collapsible-menu-view';\\n\\nconst MyDisclosureComponent = () => {\\n  const disclosureManager = React.useContext(DisclosureManagerContext);\\n\\n  return (\\n    <React.Fragment>\\n      <DisclosureManagerHeaderAdapter\\n        title=\\\"My Disclosure Component\\\"\\n        collapsibleMenuView={<CollapsibleMenuView ... />}\\n      />\\n      <Button\\n        text=\\\"Close Modal\\\"\\n        onClick={() => {\\n          disclosureManager.closeDisclosure();\\n        }}\\n      />\\n    </React.Fragment>\\n  );\\n};\\n```\\n\\n#### Children\\n\\nThe DisclosureManagerDelegate provided to the child components contains a `disclose` function. This `disclose` function validates the disclosure type with which it is provided against the set of supported disclosure types given to the DisclosureManager as a prop. If the provided type is not supported, and if the DisclosureManager detects another DisclosureManager higher in the component hierarchy, the DisclosureManager will call the disclose function provided by that parent DisclosureManager instance.\\n\\nIf the type is supported, the DisclosureManager will check the currently disclosed component's state to ensure it can be replaced. If the disclosure is denied, then `disclose` returns a rejected Promise. If the disclosure is allowed, then a resolved Promise is returned. This Promise will be resolved with an Object containing functions and Promises that can be used to manipulate the disclosure, if necessary. Included are `dismissDisclosure`, a function that will dismiss the disclosed content, and `afterDismiss`, a deferred Promise that will be resolved when the disclosed content is dismissed by any means. Alternatively, if the additional logic isn't needed, the returned Promise can be completely ignored.\\n\\nExample:\\n```jsx\\ndisclosureManager.disclose({\\n  preferredType: 'disclosure-type',\\n  size: 'large',\\n  content: {\\n    key: 'my-disclosed-content',\\n    component: <DisclosedContent />,\\n  }\\n}).then({ dismissDisclosure, afterDismiss } => {\\n  this.myContentIsDisclosed = true;\\n\\n  // This function can be cached and triggered as needed.\\n  this.myDismissFunction = dismissDisclosure;\\n\\n  afterDismiss.then(() => {\\n    // The afterDismiss will resolve when the content is dismissed, allowing for\\n    // cleanup of local state as needed.\\n    this.myContentIsDisclosed = false;\\n\\n    // If the dismissDisclosure function was cached, make sure it gets cleaned up.\\n    this.myDismissFunction = false;\\n  })\\n}).catch((e) => {\\n  // If this function is executed, the disclosure has been denied. You can use this to\\n  // clean up any state that may be reliant on the disclosure ocurring.\\n})\\n```\\n\\n`disclose` Argument API:\\n\\n|Key|Is Required|Value|\\n|---|---|---|\\n|`preferredType`|optional|The String describing the preferred disclosure type. This will be used to match the disclosure request to an appropriate DisclosureManager. Depending on the structuring of managers in a given component, the `preferredType` value may not be honored. If the provided `preferredType` is not supported by any present disclosure managers, the root disclosure manager will perform the disclosure using its own disclosure type, regardless of the `preferredType` value.|\\n|`size`|optional|The String size desired for the disclosure. One of `tiny`, `small`, `medium`, `large`, `huge`, or `fullscreen`. The functional implementation of this size is determined by the rendering component. `size` should not be provided if `dimensions` are specified.|\\n|`dimensions`|optional|An Object containing explicit `height` and `width` values for the disclosure. These values may not be honored due to the disclosure type or the available viewport size. `dimensions` should not be provided if a `size` is specified.<br />Supported `height` values include: `'240'`, `'420'`, `'600'`, `'690'`, `'780'`, `'870'`, `'960'`, `'1140'`.<br />Supported `width` values include: `'320'`, `'480'`, `'560'`, `'640'`, `'800'`, `'960'`, `'1120'`, `'1280'`, `'1440'`, `'1600'`, `'1760'`, `'1920'`.|\\n|`content`|**required**|An Object containing a key and a component describing the component to be disclosed. See the `content` API below.|\\n\\n`content` Object API:\\n\\n|Key|Is Required|Value|\\n|---|---|---|\\n|`key`|**required**|A String key identifying the component to the DisclosureManager. This key must be unique amongst the set of all actively disclosed component keys.|\\n|`component`|**required**|A React element that will be disclosed.|\\n\\n#### Disclosure Content\\n\\nIn addition to a `disclose` function, a number of other functions are exposed to components rendered in the disclosure mechanism to manage various segments of the disclosure state. The included functions are:\\n\\n|Function|Description|\\n|---|---|\\n|`disclose`|Allows a component to disclose another component. See above for argument API. The DisclosureManager implementation will determine how the next object will be disclosed.|\\n|`dismiss`|Allows a component to remove itself from the disclosure stack. If the component is the only element in the disclosure stack, the disclosure is closed.|\\n|`closeDisclosure`|Allows a component to close the entire disclosure stack. This is generally integrated into face-up disclosure controls as a Close button or similar.|\\n|`goBack`|Allows a component to remove itself from the disclosure stack. Functionally similar to `dismiss`, however `onBack` is only provided to components in the stack that have a previous sibling. This is generally integrated into face-up disclosure controls as a Back button or similar.|\\n|`maximize`|Allows a component to maximize its presentation size. This is only provided if the component is not already maximized.|\\n|`minimize`|Allows a component to minimize its presentation size. This is only provided if the component is currently maximized.|\\n|`requestFocus`|Allows a component to request focus from the disclosure in the event that the disclosure mechanism in use utilizes a focus trap. This can be integrated with the Popup and similar focus-stealing controls.|\\n|`releaseFocus`|Allows a component to release focus from itself and return it to the disclosure. This can be integrated with the Popup and similar focus-stealing controls.|\\n|`registerDismissCheck`|Allows a component to register a function with the DisclosureManager that will be called before the component is dismissed for any reason.|\\n\\nEach of these functions returns a Promise that can be used for chaining, if necessary.\\n\\n##### A Note on `registerDismissCheck`\\n\\nThe function given to registerDismissCheck must return a resolved or rejected Promise. If the Promise is resolved, the component is guaranteed to be dismissed. If cleanup logic needs to execute before the component is dismissed, it is a good idea to execute before returning the resolved Promise. If a rejected Promise is returned, the component will not be dismissed. Components can render a prompt or confirmation window to give users control over the dismissal, if desired.\\n\\nExample:\\n```jsx\\n// MyDisclosedComponent.jsx\\n\\ncomponentDidMount() {\\n  const { disclosureManager } = this.props;\\n\\n  // A dismiss function can be registered multiple times, but it usually makes sense to\\n  // register a bound function a single time on mount.\\n  disclosureManager.registerDismissCheck(this.unsavedChangesCheck);\\n}\\n\\nunsavedChangesCheck() {\\n  const { store } = this.props;\\n  const { hasUnsavedChanges } = this.state;\\n\\n  return new Promise((resolve, reject) => {\\n    if (hasUnsavedChanges) {\\n      // The dismissal could be outright denied.\\n      // reject();\\n\\n      // Or, a confirmation could allow user control.\\n      if (!confirm('MyDisclosedComponent has unsaved changes that will be lost. Do you wish to continue?')) {\\n        reject();\\n        return;\\n      }\\n\\n      // Otherwise, resolving the Promise will cause the component to be dismissed and unmounted. Any cleanup needed\\n      // before dismissal should occur before the Promise is resolved.\\n      store.dispatch(myCleanupActionOrSomething());\\n\\n      resolve();\\n    }\\n  });\\n}\\n```\\n\\n### Example\\n\\n```jsx\\n// MyDisclosureManagerImpl.jsx\\nimport React from 'react';\\nimport DisclosureManager from 'terra-disclosure-manager';\\nimport CustomDisclosure from './my/custom/disclosure';\\n\\n<DisclosureManager\\n  supportedDisclosureTypes={['my-type-1', 'my-type-2']}\\n  render={(manager) => {\\n    return (\\n      <CustomDisclosure\\n        content={manager.children.content}\\n        disclosureContent={manager.disclosure.content}\\n        isOpen={manager.disclosure.isOpen}\\n      />\\n    )\\n  }}\\n>\\n  <Component1 />\\n  <Component2 />\\n</DisclosureManager>\\n```\\n\\n## Component Features\\n\\n- [Cross-Browser Support](https://github.com/cerner/terra-ui/blob/master/src/terra-dev-site/contributing/ComponentStandards.e.contributing.md#cross-browser-support)\\n- [Responsive Support](https://github.com/cerner/terra-ui/blob/master/src/terra-dev-site/contributing/ComponentStandards.e.contributing.md#responsive-support)\\n- [Mobile Support](https://github.com/cerner/terra-ui/blob/master/src/terra-dev-site/contributing/ComponentStandards.e.contributing.md#mobile-support)\\n\"","export default \"import React from 'react';\\nimport PropTypes from 'prop-types';\\nimport DisclosureManagerDelegate from './DisclosureManagerDelegate';\\nimport DisclosureManagerContext from './DisclosureManagerContext';\\nimport DisclosureManagerHeaderAdapterContext from './DisclosureManagerHeaderAdapterContext';\\nimport DisclosureManagerHeaderAdapter from './DisclosureManagerHeaderAdapter';\\n\\nimport withDisclosureManager from './withDisclosureManager';\\n\\nconst availableDisclosureSizes = {\\n  TINY: 'tiny',\\n  SMALL: 'small',\\n  MEDIUM: 'medium',\\n  LARGE: 'large',\\n  HUGE: 'huge',\\n  FULLSCREEN: 'fullscreen',\\n};\\n\\nconst arrayReducer = (mappingObject, value) => ({ [`${value}`]: value, ...mappingObject });\\nconst availableDisclosureHeights = [240, 420, 600, 690, 780, 870, 960, 1140].reduce(arrayReducer, {});\\nconst availableDisclosureWidths = [320, 480, 560, 640, 800, 960, 1120, 1280, 1440, 1600, 1760, 1920].reduce(arrayReducer, {});\\n\\nconst defaultDimensions = { height: availableDisclosureHeights['690'], width: availableDisclosureWidths['1120'] };\\nconst defaultSize = availableDisclosureSizes.SMALL;\\n\\nconst isValidDimensions = dimensions => availableDisclosureHeights[dimensions.height] && availableDisclosureWidths[dimensions.width];\\n\\nconst isValidSize = size => !!availableDisclosureSizes[size.toUpperCase()];\\n\\nexport { availableDisclosureSizes, availableDisclosureHeights, availableDisclosureWidths };\\n\\nconst propTypes = {\\n  /**\\n   * The child components that will be provided the disclosure functionality.\\n   */\\n  children: PropTypes.node,\\n  /**\\n   * A function used to provide rendering capabilities to the DisclosureManager.\\n   */\\n  render: PropTypes.func.isRequired,\\n  /**\\n   * An array of disclosure types that the DisclosureManager should support. If an unsupported disclosure request occurs, the DisclosureManager will\\n   * utilize its 'app' prop and forward the request instead of handling the request itself.\\n   */\\n  supportedDisclosureTypes: PropTypes.array,\\n  /**\\n   * A boolean indicating whether or not the DisclosureManager should handle all nested disclosure requests. When enabled, the DisclosureManager will handle all\\n   * disclose requests coming from disclosed components, regardless of the preferred disclosure type.\\n   */\\n  trapNestedDisclosureRequests: PropTypes.bool,\\n  /**\\n   * @private\\n   * A DisclosureManagerDelegate instance provided by a parent DisclosureManager. This prop is automatically provided by `withDisclosureManager` and should not\\n   * be explicitly given to the component.\\n   */\\n  disclosureManager: DisclosureManagerDelegate.propType,\\n  /**\\n   * @private\\n   * The container to wrap the disclosed content. This should be provided from the application level.\\n   */\\n  withDisclosureContainer: PropTypes.func,\\n};\\n\\nconst defaultProps = {\\n  supportedDisclosureTypes: [],\\n};\\n\\nclass DisclosureManager extends React.Component {\\n  /**\\n   * Clones the current disclosure component state objects and returns the structure for further mutation.\\n   */\\n  static cloneDisclosureState(state) {\\n    const newState = { ...state };\\n    newState.disclosureComponentKeys = Object.assign([], newState.disclosureComponentKeys);\\n    newState.disclosureComponentData = { ...newState.disclosureComponentData };\\n    newState.disclosureComponentDelegates = Object.assign([], newState.disclosureComponentDelegates);\\n\\n    return newState;\\n  }\\n\\n  constructor(props) {\\n    super(props);\\n\\n    this.generateChildComponentDelegate = this.generateChildComponentDelegate.bind(this);\\n    this.generateDisclosureComponentDelegate = this.generateDisclosureComponentDelegate.bind(this);\\n    this.generateHeaderContextValue = this.generateHeaderContextValue.bind(this);\\n    this.generateDisclosureComponentMappingForRender = this.generateDisclosureComponentMappingForRender.bind(this);\\n\\n    this.resolveDismissPromise = this.resolveDismissPromise.bind(this);\\n    this.resolveDismissChecksInSequence = this.resolveDismissChecksInSequence.bind(this);\\n\\n    this.disclosureTypeIsSupported = this.disclosureTypeIsSupported.bind(this);\\n    this.safelyCloseDisclosure = this.safelyCloseDisclosure.bind(this);\\n    this.generatePopFunction = this.generatePopFunction.bind(this);\\n\\n    this.openDisclosure = this.openDisclosure.bind(this);\\n    this.pushDisclosure = this.pushDisclosure.bind(this);\\n    this.popDisclosure = this.popDisclosure.bind(this);\\n    this.closeDisclosure = this.closeDisclosure.bind(this);\\n    this.requestDisclosureFocus = this.requestDisclosureFocus.bind(this);\\n    this.releaseDisclosureFocus = this.releaseDisclosureFocus.bind(this);\\n    this.maximizeDisclosure = this.maximizeDisclosure.bind(this);\\n    this.minimizeDisclosure = this.minimizeDisclosure.bind(this);\\n\\n    // These cached functions are stored outside of state to prevent unnecessary rerenders.\\n    this.dismissChecks = {};\\n    this.onDismissResolvers = {};\\n\\n    this.state = {\\n      childComponentDelegate: this.generateChildComponentDelegate(),\\n      disclosureIsOpen: false,\\n      disclosureIsFocused: false,\\n      disclosureIsMaximized: false,\\n      disclosureSize: undefined,\\n      disclosureDimensions: undefined,\\n      disclosureComponentKeys: [],\\n      disclosureComponentData: {},\\n      disclosureComponentDelegates: [],\\n    };\\n  }\\n\\n  generateHeaderContextValue(key) {\\n    return {\\n      register: ({ title, collapsibleMenuView }) => {\\n        this.setState(state => ({\\n          disclosureComponentData: {\\n            ...state.disclosureComponentData,\\n            ...{\\n              [key]: { ...state.disclosureComponentData[key], headerAdapterData: { title, collapsibleMenuView } },\\n            },\\n          },\\n        }));\\n      },\\n    };\\n  }\\n\\n  generateChildComponentDelegate() {\\n    return DisclosureManagerDelegate.create({\\n      disclose: (data) => {\\n        if (this.disclosureTypeIsSupported(data.preferredType)) {\\n          return this.safelyCloseDisclosure()\\n            .then(() => {\\n              this.openDisclosure(data);\\n              /**\\n               * The disclose Promise chain is resolved with a set of APIs that the disclosing content can use to\\n               * manipulate the disclosure, if necessary.\\n               */\\n              return {\\n                /**\\n                 * The afterDismiss value is a deferred Promise that will be resolved when the disclosed component is dismissed.\\n                 */\\n                afterDismiss: new Promise((resolve) => {\\n                  this.onDismissResolvers[data.content.key] = resolve;\\n                }),\\n                /**\\n                 * The dismissDisclosure value is a function that the disclosing component can use to manually close the disclosure.\\n                 * Any and all dismiss checks are still performed.\\n                 */\\n                dismissDisclosure: this.safelyCloseDisclosure,\\n              };\\n            });\\n        }\\n\\n        return this.props.disclosureManager.disclose(data);\\n      },\\n    });\\n  }\\n\\n  generateDisclosureComponentDelegate(componentKey, disclosureState) {\\n    const {\\n      disclosureComponentKeys, disclosureComponentData, disclosureIsMaximized, disclosureIsFocused, disclosureSize,\\n    } = disclosureState;\\n\\n    const componentData = disclosureComponentData[componentKey];\\n    const isFullscreen = disclosureSize === availableDisclosureSizes.FULLSCREEN;\\n    const popContent = this.generatePopFunction(componentData.key);\\n    const componentIndex = disclosureComponentKeys.indexOf(componentKey);\\n\\n    const delegate = {};\\n\\n    /**\\n     * The disclose function provided will push content onto the disclosure stack.\\n     */\\n    delegate.disclose = (data) => {\\n      if (this.props.trapNestedDisclosureRequests || this.disclosureTypeIsSupported(data.preferredType)) {\\n        return Promise.resolve()\\n          .then(() => {\\n            this.pushDisclosure(data);\\n\\n            return {\\n              afterDismiss: new Promise((resolve) => {\\n                this.onDismissResolvers[data.content.key] = resolve;\\n              }),\\n              dismissDisclosure: this.generatePopFunction(data.content.key),\\n            };\\n          });\\n      }\\n\\n      return this.props.disclosureManager.disclose(data);\\n    };\\n\\n    /**\\n     * Allows a component to remove itself from the disclosure stack. If the component is the only element in the disclosure stack,\\n     * the disclosure is closed.\\n     */\\n    delegate.dismiss = popContent;\\n\\n    /**\\n     * Allows a component to close the entire disclosure stack.\\n     */\\n    delegate.closeDisclosure = this.safelyCloseDisclosure;\\n\\n    /**\\n     * Allows a component to remove itself from the disclosure stack. Functionally similar to `dismiss`, however `onBack` is\\n     * only provided to components in the stack that have a previous sibling.\\n     */\\n    delegate.goBack = componentIndex > 0 ? popContent : undefined;\\n\\n    /**\\n     * Allows a component to request focus from the disclosure in the event that the disclosure mechanism in use utilizes a focus trap.\\n     */\\n    delegate.requestFocus = disclosureIsFocused ? () => Promise.resolve().then(this.releaseDisclosureFocus) : undefined;\\n\\n    /**\\n     * Allows a component to release focus from itself and return it to the disclosure.\\n     */\\n    delegate.releaseFocus = !disclosureIsFocused ? () => Promise.resolve().then(this.requestDisclosureFocus) : undefined;\\n\\n    /**\\n     * Allows a component to maximize its presentation size. This is only provided if the component is not already maximized.\\n     */\\n    delegate.maximize = (!isFullscreen && !disclosureIsMaximized) ? () => (Promise.resolve().then(this.maximizeDisclosure)) : undefined;\\n\\n    /**\\n     * Allows a component to minimize its presentation size. This is only provided if the component is currently maximized.\\n     */\\n    delegate.minimize = (!isFullscreen && disclosureIsMaximized) ? () => (Promise.resolve().then(this.minimizeDisclosure)) : undefined;\\n\\n    /**\\n     * Allows a component to register a function with the DisclosureManager that will be called before the component is dismissed for any reason.\\n     */\\n    delegate.registerDismissCheck = (checkFunc) => {\\n      const { disclosureManager } = this.props;\\n\\n      this.dismissChecks[componentData.key] = checkFunc;\\n\\n      if (disclosureManager && disclosureManager.registerDismissCheck) {\\n        // The combination of all managed dismiss checks is registered to the parent app delegate to ensure\\n        // that all are accounted for by the parent.\\n        // eslint-disable-next-line compat/compat\\n        return disclosureManager.registerDismissCheck(() => Promise.all(Object.values(this.dismissChecks)));\\n      }\\n\\n      return Promise.resolve();\\n    };\\n\\n    return DisclosureManagerDelegate.create(delegate);\\n  }\\n\\n  /**\\n   * Determines if the provided disclosure type is supported by the DisclosureManager.\\n   * @return `true` if the type is supported or if there is no fallback `disclosureManager` present. `false` is returned otherwise.\\n   */\\n  disclosureTypeIsSupported(type) {\\n    const { disclosureManager, supportedDisclosureTypes } = this.props;\\n\\n    return supportedDisclosureTypes.indexOf(type) >= 0 || !disclosureManager;\\n  }\\n\\n  openDisclosure(data) {\\n    let { dimensions } = data;\\n    if (dimensions && !isValidDimensions(dimensions)) {\\n      // dimensions were provided, but are invalid, set the default\\n      dimensions = defaultDimensions;\\n    }\\n\\n    // eslint-disable-next-line prefer-destructuring\\n    let size = data.size;\\n    if (!size || (size && !isValidSize(size))) {\\n      // no valid size passed\\n      if (!dimensions) {\\n        // no valid size and no valid dimensions, set the default\\n        dimensions = defaultDimensions;\\n      }\\n      // ensure size set for pacivity\\n      size = defaultSize;\\n    }\\n\\n    const newState = {\\n      disclosureIsOpen: true,\\n      disclosureIsFocused: true,\\n      disclosureSize: size,\\n      disclosureDimensions: dimensions,\\n      disclosureComponentKeys: [data.content.key],\\n      disclosureComponentData: {\\n        [data.content.key]: {\\n          key: data.content.key,\\n          name: data.content.name,\\n          props: data.content.props,\\n          component: data.content.component,\\n          headerAdapterContextValue: this.generateHeaderContextValue(data.content.key),\\n        },\\n      },\\n    };\\n    newState.disclosureComponentDelegates = [this.generateDisclosureComponentDelegate(data.content.key, newState)];\\n\\n    this.setState(newState);\\n  }\\n\\n  pushDisclosure(data) {\\n    const newState = DisclosureManager.cloneDisclosureState(this.state);\\n\\n    newState.disclosureComponentKeys.push(data.content.key);\\n    newState.disclosureComponentData[data.content.key] = {\\n      key: data.content.key,\\n      name: data.content.name,\\n      props: data.content.props,\\n      component: data.content.component,\\n      headerAdapterContextValue: this.generateHeaderContextValue(data.content.key),\\n    };\\n    newState.disclosureComponentDelegates = newState.disclosureComponentDelegates.concat(this.generateDisclosureComponentDelegate(data.content.key, newState));\\n\\n    this.setState(newState);\\n  }\\n\\n  popDisclosure(callbackfunction) {\\n    /**\\n     * If there is only one disclosed component, the disclosure is closed and all state is reset.\\n     */\\n    if (this.state.disclosureComponentKeys.length === 1) {\\n      this.closeDisclosure(callbackfunction);\\n    } else {\\n      const newState = DisclosureManager.cloneDisclosureState(this.state);\\n\\n      newState.disclosureComponentData[newState.disclosureComponentKeys.pop()] = undefined;\\n      newState.disclosureComponentDelegates.pop();\\n\\n      this.setState(newState, callbackfunction);\\n    }\\n  }\\n\\n  closeDisclosure(callbackfunction) {\\n    this.setState({\\n      disclosureIsOpen: false,\\n      disclosureIsFocused: false,\\n      disclosureIsMaximized: false,\\n      disclosureSize: undefined,\\n      disclosureDimensions: undefined,\\n      disclosureComponentKeys: [],\\n      disclosureComponentData: {},\\n      disclosureComponentDelegates: [],\\n    }, callbackfunction);\\n  }\\n\\n  requestDisclosureFocus() {\\n    const newState = DisclosureManager.cloneDisclosureState(this.state);\\n    newState.disclosureIsFocused = true;\\n    newState.disclosureComponentDelegates = newState.disclosureComponentKeys.map(key => this.generateDisclosureComponentDelegate(key, newState));\\n\\n    this.setState(newState);\\n  }\\n\\n  releaseDisclosureFocus() {\\n    const newState = DisclosureManager.cloneDisclosureState(this.state);\\n    newState.disclosureIsFocused = false;\\n    newState.disclosureComponentDelegates = newState.disclosureComponentKeys.map(key => this.generateDisclosureComponentDelegate(key, newState));\\n\\n    this.setState(newState);\\n  }\\n\\n  maximizeDisclosure() {\\n    const newState = DisclosureManager.cloneDisclosureState(this.state);\\n    newState.disclosureIsMaximized = true;\\n    newState.disclosureComponentDelegates = newState.disclosureComponentKeys.map(key => this.generateDisclosureComponentDelegate(key, newState));\\n\\n    this.setState(newState);\\n  }\\n\\n  minimizeDisclosure() {\\n    const newState = DisclosureManager.cloneDisclosureState(this.state);\\n    newState.disclosureIsMaximized = false;\\n    newState.disclosureComponentDelegates = newState.disclosureComponentKeys.map(key => this.generateDisclosureComponentDelegate(key, newState));\\n\\n    this.setState(newState);\\n  }\\n\\n  /**\\n   * Looks up the deferred afterDismiss promise for the provided disclosure key and\\n   * resolves it.\\n   */\\n  resolveDismissPromise(key) {\\n    const resolve = this.onDismissResolvers[key];\\n    if (resolve) {\\n      resolve();\\n    }\\n    this.onDismissResolvers[key] = undefined;\\n  }\\n\\n  /**\\n   * Resolves the dismiss checks for the current disclosure components in sequence. The Promise will either resolve if all checks resolve or\\n   * reject on the first detected rejection. This ensures that checks do not occur for components after the first rejection.\\n   */\\n  resolveDismissChecksInSequence(keys) {\\n    return new Promise((resolve, reject) => {\\n      if (!keys.length) {\\n        resolve();\\n        return;\\n      }\\n\\n      const key = keys.pop();\\n\\n      this.generatePopFunction(key)()\\n        .then(() => {\\n          this.resolveDismissChecksInSequence(keys).then(resolve).catch(reject);\\n        })\\n        .catch(() => {\\n          reject();\\n        });\\n    });\\n  }\\n\\n  /**\\n   * Closes the disclosure after calling all checks and resolving all deferred promises.\\n   * @return A Promise, resolved if the close was performed or rejected if it was not.\\n   */\\n  safelyCloseDisclosure() {\\n    const disclosureKeys = Object.assign([], this.state.disclosureComponentKeys);\\n\\n    /**\\n     * Before closing the disclosure, the dismiss checks for components in the stack are\\n     * executed in stack order. Components will be dismissed in order up until a rejection occurs, at which point\\n     * the blocking component will be presented.\\n     */\\n    return this.resolveDismissChecksInSequence(disclosureKeys).then(() => {\\n      this.dismissChecks = {};\\n      this.closeDisclosure();\\n    });\\n  }\\n\\n  /**\\n   * Creates an instance of a pop function for the component represented by the given key.\\n   */\\n  generatePopFunction(key) {\\n    return () => {\\n      const { disclosureComponentKeys } = this.state;\\n\\n      if (disclosureComponentKeys[disclosureComponentKeys.length - 1] !== key) {\\n        /**\\n         * If the top component key in the disclosure stack does not match\\n         * the key used to generate this function, or the key is undefined, then the pop action is rejected.\\n         */\\n        return Promise.reject();\\n      }\\n\\n      let promiseRoot = Promise.resolve();\\n      const dismissCheck = this.dismissChecks[key];\\n\\n      if (dismissCheck) {\\n        promiseRoot = dismissCheck();\\n      }\\n\\n      const callbackfunction = () => {\\n        this.dismissChecks[key] = undefined;\\n        this.resolveDismissPromise(key);\\n      };\\n\\n      return promiseRoot\\n        .then(() => {\\n          this.popDisclosure(callbackfunction);\\n        });\\n    };\\n  }\\n\\n  generateDisclosureComponentMappingForRender(withDisclosureContainer) {\\n    const {\\n      disclosureComponentKeys,\\n      disclosureComponentData,\\n      disclosureComponentDelegates,\\n    } = this.state;\\n\\n    return disclosureComponentKeys.reduce((accumulator, key, index) => {\\n      const componentData = disclosureComponentData[key];\\n      const component = withDisclosureContainer ? withDisclosureContainer(componentData.component) : componentData.component;\\n      accumulator[key] = {\\n        component: (\\n          <DisclosureManagerHeaderAdapterContext.Provider value={componentData.headerAdapterContextValue} key={key}>\\n            <DisclosureManagerContext.Provider value={disclosureComponentDelegates[index]}>\\n              {component}\\n            </DisclosureManagerContext.Provider>\\n          </DisclosureManagerHeaderAdapterContext.Provider>\\n        ),\\n        headerAdapterData: componentData.headerAdapterData,\\n      };\\n\\n      return accumulator;\\n    }, {});\\n  }\\n\\n  render() {\\n    const { withDisclosureContainer, render, children } = this.props;\\n    const {\\n      childComponentDelegate,\\n      disclosureIsOpen,\\n      disclosureIsFocused,\\n      disclosureIsMaximized,\\n      disclosureSize,\\n      disclosureDimensions,\\n      disclosureComponentKeys,\\n    } = this.state;\\n\\n    if (!render) {\\n      return null;\\n    }\\n    const disclosureComponentMappingForRender = this.generateDisclosureComponentMappingForRender(withDisclosureContainer);\\n\\n    return render({\\n      dismissPresentedComponent: this.generatePopFunction(disclosureComponentKeys ? disclosureComponentKeys[disclosureComponentKeys.length - 1] : undefined),\\n      closeDisclosure: this.safelyCloseDisclosure,\\n      maximizeDisclosure: (disclosureSize !== availableDisclosureSizes.FULLSCREEN && !disclosureIsMaximized) ? () => Promise.resolve().then(this.maximizeDisclosure) : undefined,\\n      minimizeDisclosure: (disclosureSize !== availableDisclosureSizes.FULLSCREEN && disclosureIsMaximized) ? () => Promise.resolve().then(this.minimizeDisclosure) : undefined,\\n      children: {\\n        components: (\\n          <DisclosureManagerContext.Provider value={childComponentDelegate}>\\n            {children}\\n          </DisclosureManagerContext.Provider>\\n        ),\\n      },\\n      disclosure: {\\n        isOpen: disclosureIsOpen,\\n        isFocused: disclosureIsFocused,\\n        isMaximized: disclosureIsMaximized,\\n        size: disclosureSize,\\n        dimensions: disclosureDimensions,\\n        components: disclosureComponentKeys.map(key => disclosureComponentMappingForRender[key].component),\\n      },\\n      /**\\n       * The below values were added to give DisclosureManager implementations more control over the rendering of the disclosed components.\\n       * Some of the data provided by these keys is duplicated by the data provided in the above `disclose` value.\\n       * In a future major release, this render object will be restructured and simplified. Until then, either can be used as needed.\\n       */\\n      disclosureComponentKeys,\\n      disclosureComponentData: disclosureComponentMappingForRender,\\n    });\\n  }\\n}\\n\\nDisclosureManager.propTypes = propTypes;\\nDisclosureManager.defaultProps = defaultProps;\\n\\nconst disclosureManagerShape = DisclosureManagerDelegate.propType;\\n\\nexport default withDisclosureManager(DisclosureManager);\\nexport {\\n  withDisclosureManager, disclosureManagerShape, DisclosureManagerContext, DisclosureManagerDelegate, DisclosureManagerHeaderAdapterContext, DisclosureManagerHeaderAdapter,\\n};\\n\"","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _terraDocTemplate = _interopRequireDefault(require(\"terra-doc-template\"));\n\nvar _package = require(\"../../../../package.json\");\n\nvar _README = _interopRequireDefault(require(\"../../../../docs/README.md\"));\n\nvar _DisclosureManager = _interopRequireDefault(require(\"!raw-loader!../../../../src/DisclosureManager.jsx\"));\n\n// Component Source\nvar DocPage = function DocPage() {\n  return _react.default.createElement(_terraDocTemplate.default, {\n    packageName: _package.name,\n    readme: _README.default,\n    srcPath: \"https://github.com/cerner/terra-framework/tree/master/packages/\".concat(_package.name),\n    propsTables: [{\n      componentSrc: _DisclosureManager.default\n    }]\n  });\n};\n\nvar _default = DocPage;\nexports.default = _default;"],"sourceRoot":""}